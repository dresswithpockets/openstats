// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package query

import (
	"context"
	"database/sql"
	"time"
)

const addUserDisplayName = `-- name: AddUserDisplayName :exec
insert into user_display_name (user_id, display_name)
values (?, ?)
`

type AddUserDisplayNameParams struct {
	UserID      int64
	DisplayName string
}

func (q *Queries) AddUserDisplayName(ctx context.Context, arg AddUserDisplayNameParams) error {
	_, err := q.db.ExecContext(ctx, addUserDisplayName, arg.UserID, arg.DisplayName)
	return err
}

const addUserEmail = `-- name: AddUserEmail :exec
insert into user_email (updated_at, user_id, email)
values (datetime('now'), ?, ?)
`

type AddUserEmailParams struct {
	UserID int64
	Email  string
}

func (q *Queries) AddUserEmail(ctx context.Context, arg AddUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, addUserEmail, arg.UserID, arg.Email)
	return err
}

const addUserSlugRecord = `-- name: AddUserSlugRecord :exec
insert into user_slug (user_id, slug)
values (?, ?)
`

type AddUserSlugRecordParams struct {
	UserID int64
	Slug   string
}

func (q *Queries) AddUserSlugRecord(ctx context.Context, arg AddUserSlugRecordParams) error {
	_, err := q.db.ExecContext(ctx, addUserSlugRecord, arg.UserID, arg.Slug)
	return err
}

const allUsersWithDisplayNames = `-- name: AllUsersWithDisplayNames :many
select u.id, u.created_at, u.updated_at, u.deleted_at, u.slug, udn1.display_name
from user u
     left outer join user_display_name udn1 on u.id = udn1.user_id and udn1.deleted_at is null
     left outer join user_display_name udn2 on u.id = udn2.user_id and udn2.deleted_at is null and
                                               (udn1.created_at < udn2.created_at or
                                                (udn1.created_at = udn2.created_at and udn1.id < udn2.id))
where udn2.id is null
`

type AllUsersWithDisplayNamesRow struct {
	ID          int64
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	Slug        string
	DisplayName sql.NullString
}

func (q *Queries) AllUsersWithDisplayNames(ctx context.Context) ([]AllUsersWithDisplayNamesRow, error) {
	rows, err := q.db.QueryContext(ctx, allUsersWithDisplayNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllUsersWithDisplayNamesRow
	for rows.Next() {
		var i AllUsersWithDisplayNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Slug,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createUser = `-- name: CreateUser :one
insert into user (updated_at, slug)
values (datetime('now'), ?)
returning id, created_at, updated_at, deleted_at, slug
`

func (q *Queries) CreateUser(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
	)
	return i, err
}

const createUserPassword = `-- name: CreateUserPassword :exec
insert into user_password (updated_at, user_id, encoded_hash)
values (datetime('now'), ?, ?)
`

type CreateUserPasswordParams struct {
	UserID      int64
	EncodedHash string
}

func (q *Queries) CreateUserPassword(ctx context.Context, arg CreateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, createUserPassword, arg.UserID, arg.EncodedHash)
	return err
}

const findUser = `-- name: FindUser :one
select id, created_at, updated_at, deleted_at, slug
from user
where id = ?
limit 1
`

func (q *Queries) FindUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, findUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
	)
	return i, err
}

const findUserBySlug = `-- name: FindUserBySlug :one
select id, created_at, updated_at, deleted_at, slug
from user
where slug = ?
limit 1
`

func (q *Queries) FindUserBySlug(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserBySlug, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
	)
	return i, err
}

const findUserBySlugWithPassword = `-- name: FindUserBySlugWithPassword :one
select user.id, user.created_at, user.updated_at, user.deleted_at, user.slug, user_password.encoded_hash
from user
     join user_password on user.id = user_password.user_id
where user.slug = ?
  and user.deleted_at is null
limit 1
`

type FindUserBySlugWithPasswordRow struct {
	ID          int64
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	Slug        string
	EncodedHash string
}

func (q *Queries) FindUserBySlugWithPassword(ctx context.Context, slug string) (FindUserBySlugWithPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, findUserBySlugWithPassword, slug)
	var i FindUserBySlugWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Slug,
		&i.EncodedHash,
	)
	return i, err
}

const getOtherUserRecentAchievements = `-- name: GetOtherUserRecentAchievements :many
select a.name, g.slug as game_name
from achievement_progress ap
     join achievement a on ap.achievement_id = a.id
     join user u on ap.user_id = u.id
     join game g on a.game_id = g.id
where u.id != ?2
  and ap.progress >= a.progress_requirement
  and u.deleted_at is null
  and g.deleted_at is null
  and a.deleted_at is null
  and ap.deleted_at is null
order by ap.created_at desc
limit ?
`

type GetOtherUserRecentAchievementsParams struct {
	UserID int64
	Limit  int64
}

type GetOtherUserRecentAchievementsRow struct {
	Name     string
	GameName string
}

func (q *Queries) GetOtherUserRecentAchievements(ctx context.Context, arg GetOtherUserRecentAchievementsParams) ([]GetOtherUserRecentAchievementsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOtherUserRecentAchievements, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOtherUserRecentAchievementsRow
	for rows.Next() {
		var i GetOtherUserRecentAchievementsRow
		if err := rows.Scan(&i.Name, &i.GameName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDevelopers = `-- name: GetUserDevelopers :many
select d.slug, d.created_at, d.deleted_at, dm.created_at as joined_at, dm.deleted_at as left_at
from developer_member dm
     join developer d on dm.developer_id = d.id
where dm.user_id = ?
`

type GetUserDevelopersRow struct {
	Slug      string
	CreatedAt time.Time
	DeletedAt sql.NullTime
	JoinedAt  time.Time
	LeftAt    sql.NullTime
}

func (q *Queries) GetUserDevelopers(ctx context.Context, userID int64) ([]GetUserDevelopersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserDevelopers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDevelopersRow
	for rows.Next() {
		var i GetUserDevelopersRow
		if err := rows.Scan(
			&i.Slug,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.JoinedAt,
			&i.LeftAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDisplayNames = `-- name: GetUserDisplayNames :many
select id, created_at, deleted_at, user_id, display_name
from user_display_name
where user_id = ?
`

func (q *Queries) GetUserDisplayNames(ctx context.Context, userID int64) ([]UserDisplayName, error) {
	rows, err := q.db.QueryContext(ctx, getUserDisplayNames, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserDisplayName
	for rows.Next() {
		var i UserDisplayName
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEmails = `-- name: GetUserEmails :many
select id, created_at, updated_at, deleted_at, user_id, email, confirmed_at
from user_email
where user_id = ?
`

func (q *Queries) GetUserEmails(ctx context.Context, userID int64) ([]UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, getUserEmails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Email,
			&i.ConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRecentAchievements = `-- name: GetUserRecentAchievements :many
select a.name, g.slug as game_name
from achievement_progress ap
     join achievement a on ap.achievement_id = a.id
     join user u on ap.user_id = u.id
     join game g on a.game_id = g.id
where u.id = ?2
  and ap.progress >= a.progress_requirement
  and u.deleted_at is null
  and g.deleted_at is null
  and a.deleted_at is null
  and ap.deleted_at is null
order by ap.created_at desc
limit ?
`

type GetUserRecentAchievementsParams struct {
	UserID int64
	Limit  int64
}

type GetUserRecentAchievementsRow struct {
	Name     string
	GameName string
}

func (q *Queries) GetUserRecentAchievements(ctx context.Context, arg GetUserRecentAchievementsParams) ([]GetUserRecentAchievementsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserRecentAchievements, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRecentAchievementsRow
	for rows.Next() {
		var i GetUserRecentAchievementsRow
		if err := rows.Scan(&i.Name, &i.GameName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
