// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: achievement.sql

package query

import (
	"context"
)

const findAchievementBySlug = `-- name: FindAchievementBySlug :one
select a.id, a.created_at, a.updated_at, a.deleted_at, a.game_id, a.slug, a.name, a.description, a.progress_requirement
from achievement a
     join game g on a.game_id = g.id
     join developer d on g.developer_id = d.id
where a.slug = ?
  and d.slug = ?2
  and g.slug = ?3
limit 1
`

type FindAchievementBySlugParams struct {
	Slug     string
	DevSlug  string
	GameSlug string
}

func (q *Queries) FindAchievementBySlug(ctx context.Context, arg FindAchievementBySlugParams) (Achievement, error) {
	row := q.db.QueryRowContext(ctx, findAchievementBySlug, arg.Slug, arg.DevSlug, arg.GameSlug)
	var i Achievement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.GameID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.ProgressRequirement,
	)
	return i, err
}

const upsertAchievement = `-- name: UpsertAchievement :one
insert into achievement (updated_at, game_id, slug, name, description, progress_requirement)
values (datetime('now'), ?, ?, ?, ?, ?)
on conflict(game_id, slug)
    do update set name=excluded.name,
                  description=excluded.description,
                  progress_requirement=excluded.progress_requirement
returning case when achievement.created_at == achievement.updated_at then true else false end as upsert_was_insert
`

type UpsertAchievementParams struct {
	GameID              int64
	Slug                string
	Name                string
	Description         string
	ProgressRequirement int64
}

func (q *Queries) UpsertAchievement(ctx context.Context, arg UpsertAchievementParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertAchievement,
		arg.GameID,
		arg.Slug,
		arg.Name,
		arg.Description,
		arg.ProgressRequirement,
	)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}
