// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUser = `-- name: AddUser :one
insert into users (slug) values ($1) returning id, created_at, updated_at, slug
`

func (q *Queries) AddUser(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRow(ctx, addUser, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
	)
	return i, err
}

const addUserDisplayName = `-- name: AddUserDisplayName :exec
insert into user_display_name(user_id, display_name) values ($1, $2)
`

type AddUserDisplayNameParams struct {
	UserID      int32
	DisplayName string
}

func (q *Queries) AddUserDisplayName(ctx context.Context, arg AddUserDisplayNameParams) error {
	_, err := q.db.Exec(ctx, addUserDisplayName, arg.UserID, arg.DisplayName)
	return err
}

const addUserEmail = `-- name: AddUserEmail :exec
insert into user_email(user_id, email) values ($1, $2)
`

type AddUserEmailParams struct {
	UserID int32
	Email  string
}

func (q *Queries) AddUserEmail(ctx context.Context, arg AddUserEmailParams) error {
	_, err := q.db.Exec(ctx, addUserEmail, arg.UserID, arg.Email)
	return err
}

const addUserPassword = `-- name: AddUserPassword :exec
insert into user_password(user_id, encoded_hash) values ($1, $2)
`

type AddUserPasswordParams struct {
	UserID      int32
	EncodedHash string
}

func (q *Queries) AddUserPassword(ctx context.Context, arg AddUserPasswordParams) error {
	_, err := q.db.Exec(ctx, addUserPassword, arg.UserID, arg.EncodedHash)
	return err
}

const addUserSlugHistory = `-- name: AddUserSlugHistory :exec
insert into user_slug_history(user_id, slug) values ($1, $2)
`

type AddUserSlugHistoryParams struct {
	UserID int32
	Slug   string
}

func (q *Queries) AddUserSlugHistory(ctx context.Context, arg AddUserSlugHistoryParams) error {
	_, err := q.db.Exec(ctx, addUserSlugHistory, arg.UserID, arg.Slug)
	return err
}

const allUsersWithDisplayNames = `-- name: AllUsersWithDisplayNames :many
select u.id, u.created_at, u.updated_at, u.slug, udn1.display_name
from users u
     left outer join user_display_name udn1 on u.id = udn1.user_id
     left outer join user_display_name udn2 on u.id = udn2.user_id and
                                               (udn1.created_at < udn2.created_at or
                                                (udn1.created_at = udn2.created_at and udn1.id < udn2.id))
where udn2.id is null
`

type AllUsersWithDisplayNamesRow struct {
	ID          int32
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Slug        string
	DisplayName pgtype.Text
}

func (q *Queries) AllUsersWithDisplayNames(ctx context.Context) ([]AllUsersWithDisplayNamesRow, error) {
	rows, err := q.db.Query(ctx, allUsersWithDisplayNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllUsersWithDisplayNamesRow
	for rows.Next() {
		var i AllUsersWithDisplayNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Slug,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUser = `-- name: FindUser :one
select id, created_at, updated_at, slug from users where id = $1 limit 1
`

func (q *Queries) FindUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, findUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
	)
	return i, err
}

const findUserBySlug = `-- name: FindUserBySlug :one
select id, created_at, updated_at, slug
from users
where slug = $1
limit 1
`

func (q *Queries) FindUserBySlug(ctx context.Context, slug string) (User, error) {
	row := q.db.QueryRow(ctx, findUserBySlug, slug)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
	)
	return i, err
}

const findUserBySlugWithPassword = `-- name: FindUserBySlugWithPassword :one
select u.id, u.created_at, u.updated_at, u.slug, up.encoded_hash
from users u
     join user_password up on u.id = up.user_id
where u.slug = $1
limit 1
`

type FindUserBySlugWithPasswordRow struct {
	ID          int32
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Slug        string
	EncodedHash string
}

func (q *Queries) FindUserBySlugWithPassword(ctx context.Context, slug string) (FindUserBySlugWithPasswordRow, error) {
	row := q.db.QueryRow(ctx, findUserBySlugWithPassword, slug)
	var i FindUserBySlugWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.EncodedHash,
	)
	return i, err
}

const getOtherUserRecentAchievements = `-- name: GetOtherUserRecentAchievements :many
select d.slug as developer_slug, g.slug as game_slug, '' as game_name, a.slug as slug, a.name as name, a.description as description, u.slug as user_slug, udn1.display_name as user_display_name
from achievement_progress ap
     join achievement a on ap.achievement_id = a.id
     join users u on ap.user_id = u.id
     join game g on a.game_id = g.id
     join developer d on g.developer_id = d.id
     left outer join user_display_name udn1 on u.id = udn1.user_id
     left outer join user_display_name udn2 on u.id = udn2.user_id and
                                               (udn1.created_at < udn2.created_at or
                                                (udn1.created_at = udn2.created_at and udn1.id < udn2.id))
where u.slug != $2
  and ap.progress >= a.progress_requirement
order by ap.created_at desc
limit $1
`

type GetOtherUserRecentAchievementsParams struct {
	Limit            int32
	ExcludedUserSlug string
}

type GetOtherUserRecentAchievementsRow struct {
	DeveloperSlug   string
	GameSlug        string
	GameName        string
	Slug            string
	Name            string
	Description     string
	UserSlug        string
	UserDisplayName pgtype.Text
}

func (q *Queries) GetOtherUserRecentAchievements(ctx context.Context, arg GetOtherUserRecentAchievementsParams) ([]GetOtherUserRecentAchievementsRow, error) {
	rows, err := q.db.Query(ctx, getOtherUserRecentAchievements, arg.Limit, arg.ExcludedUserSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOtherUserRecentAchievementsRow
	for rows.Next() {
		var i GetOtherUserRecentAchievementsRow
		if err := rows.Scan(
			&i.DeveloperSlug,
			&i.GameSlug,
			&i.GameName,
			&i.Slug,
			&i.Name,
			&i.Description,
			&i.UserSlug,
			&i.UserDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDevelopers = `-- name: GetUserDevelopers :many
select d.slug, d.created_at, dm.created_at as joined_at
from developer_member dm
     join developer d on dm.developer_id = d.id
where dm.user_id = $1
`

type GetUserDevelopersRow struct {
	Slug      string
	CreatedAt pgtype.Timestamptz
	JoinedAt  pgtype.Timestamptz
}

func (q *Queries) GetUserDevelopers(ctx context.Context, userID int32) ([]GetUserDevelopersRow, error) {
	rows, err := q.db.Query(ctx, getUserDevelopers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDevelopersRow
	for rows.Next() {
		var i GetUserDevelopersRow
		if err := rows.Scan(&i.Slug, &i.CreatedAt, &i.JoinedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDisplayNames = `-- name: GetUserDisplayNames :many
select id, created_at, user_id, display_name
from user_display_name
where user_id = $1
`

func (q *Queries) GetUserDisplayNames(ctx context.Context, userID int32) ([]UserDisplayName, error) {
	rows, err := q.db.Query(ctx, getUserDisplayNames, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserDisplayName
	for rows.Next() {
		var i UserDisplayName
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UserID,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEmails = `-- name: GetUserEmails :many
select id, created_at, updated_at, user_id, email, confirmed_at
from user_email
where user_id = $1
`

func (q *Queries) GetUserEmails(ctx context.Context, userID int32) ([]UserEmail, error) {
	rows, err := q.db.Query(ctx, getUserEmails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Email,
			&i.ConfirmedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLatestDisplayName = `-- name: GetUserLatestDisplayName :one
select id, created_at, user_id, display_name
from user_display_name udn
where udn.user_id = $1
order by udn.created_at desc
limit 1
`

func (q *Queries) GetUserLatestDisplayName(ctx context.Context, userID int32) (UserDisplayName, error) {
	row := q.db.QueryRow(ctx, getUserLatestDisplayName, userID)
	var i UserDisplayName
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UserID,
		&i.DisplayName,
	)
	return i, err
}

const getUserRecentAchievements = `-- name: GetUserRecentAchievements :many
select d.slug as developer_slug, g.slug as game_slug, '' as game_name, a.slug as slug, a.name as name, a.description as description
from achievement_progress ap
     join achievement a on ap.achievement_id = a.id
     join users u on ap.user_id = u.id
     join game g on a.game_id = g.id
     join developer d on g.developer_id = d.id
where u.slug = $2
  and ap.progress >= a.progress_requirement
order by ap.created_at desc
limit $1
`

type GetUserRecentAchievementsParams struct {
	Limit    int32
	UserSlug string
}

type GetUserRecentAchievementsRow struct {
	DeveloperSlug string
	GameSlug      string
	GameName      string
	Slug          string
	Name          string
	Description   string
}

func (q *Queries) GetUserRecentAchievements(ctx context.Context, arg GetUserRecentAchievementsParams) ([]GetUserRecentAchievementsRow, error) {
	rows, err := q.db.Query(ctx, getUserRecentAchievements, arg.Limit, arg.UserSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRecentAchievementsRow
	for rows.Next() {
		var i GetUserRecentAchievementsRow
		if err := rows.Scan(
			&i.DeveloperSlug,
			&i.GameSlug,
			&i.GameName,
			&i.Slug,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
